### 정의 (Test Driven Development)

- “테스트 주도 개발이라는 의미로, 작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 구현하는 단계를 반복적으로 수행하며 소프트웨어(프로그래밍)을 구현한다는 방법론
- 보통의 프로그래밍 개발
    - 설계 -> 개발 -> 테스트의 단계
- TDD는 테스트를 먼저 만들어 내고, 이를 구현하고, 리팩토링하는 짧은 개발주기를 반복하여 Extream Programming을 실현

  > Extream Programming : 미래에 대한 예측을 줄이고, 지속적으로 프로토타입을 완성하는 애자일 방법론 중 하나.
  >

### 기댓값

- 빠른 피드백
    - 기존 방식의 문제점
        - 의뢰자의 요구사항이 초기단계와 항상 동일 할 수 없기 때문에 설계는 항상 변함
        - 로직이 변해도 클라이언트의 코드는 변하면 안됨
        - 부분적인 변경사항에 대해서도 테스트를 위해 모든 프로그램 과정(로직)을 테스트해야하며 이로 인한 버그 발생시, 어느 부분이 버그를 유발하는지 명확하게 찾아내기 어려움
    - TDD의 단위 테스트
        - 단위마다 테스트를 진행하며, 버그를 유발하는 부분에 대해 순간순간 찾아낼 수 있음
            - 코드가 개발자의 손들 벗어난 뒤, 가장 빠르게 피드백
- 결정과 피드백 사이의 갭

  > 결정(decision) : 개발 과정에서 '이 방법으로 해야지', '이걸 사용해서 해결해야지'와 같은 결정
  >
  >
  > `피드백(feedback)` : 프로그램의 성공/실패라는 결과
  >
    - "이 방법으로 해야지"`결정` 의 "실패" `피드백` 의 간격을 인식하는 것이 프로그램을 의도한 대로 작동하는데 중요
    - 개발자의 결정과 피드백 간의 간격을 줄이는 데 도움을 줌
- 코드 트래킹의 용이성
    - 테스트 코드 하나하나가 만들어진 프로그램의 로직을 설명하는 근거
    - 그 당시의 결정에 대한 이유와 그 과정을 살필 수 있기 때문에 돌아보는데 있어 유리

### TDD Always?

- 개발 시간에 대한 의문
    - 코드량이 늘어나기에 프로그래밍 규모가 크다면 시간 대비 비용이 큼
    - TDD가 코드의 길이가 늘어나는 것은 맞지만, 어느 수준의 프로그램에서는 전체적인 시간이 줄어듬
        - 기존방식에서 버그를 잡기위해 소모되는 시간이 줄어듬
- 버그가 없는지에 대한 의문
    - 버그를 보다 빠르고 효과적으로 개선할 수 있을 뿐, 완전히 없다고 보장할 순 없음
- TDD가 익숙하지 않음
    - 체득되기 전에 적용하기 어려움

### TDD Process

- RED
    - 테스트 실패
    - 구현해야할 기능에 대한 명확한 요구사항 테스트로 작성
    - 테스트 수행
    - 처음 작성한 테스트는 해당 테스트를 구현한 코드가 아직 존재하지 않기 때문에 무조건 실패
- GREEN : 테스트 성공
    - 추가된 테스트를 반영하여 구현 코드를 작성
    - 테스트 성공을 위한 최소한의 코드 작성 및 변경
- REFACTOR : 리팩토링
    - 설계 개선
    - 테스트 코드는 일종의 클라이언트. 내가 서비스 코드를 변경했는데 클라이언트 코드가 바뀐다면 설계가 나쁜 것
    - 클라이언트 입장에서 코드를 보면서 보이는 설계적인 문제점을 리팩토링

### Mock을 적극적으로 활용하는게 좋을까?

- 테스트에 이용하는 데이터는 동일하기에 비슷한 코드로 보일 수 있지만 테스트는 목킹에 의한 가정을 이용하고 있기 때문에 내부 구현에 의존
- 실제로 service 내부 로직이 변경되어 목킹한 repository를 이용하지 않거나 다른 메서드를 호출하게 되면 의미 없는 목킹에 의한 예외를 일으키기도함
    - 스펙에 대한 변경 없이 내부 구현이 변경된 리팩터링에도 테스트가 쉽게 깨지게 됨
- 좋은 단위 테스트의 특성
    - 리팩터링 내성
        - 스펙이 변한 게 아니라 리팩터링으로 내부구조만 변했다면 테스트는 여전히 통과해야 한다는 것
- 가정들을 정의하게 되고, 이에 대한 코드가 길어져서 실제 테스트코드보다 목킹 코드가 더 많아지는 것 또한 테스트 코드를 이해하는데 어렵게 만드는 요소
- TDD 방식으로 코드를 작성하게 된다면 구현 코드가 없는 상태에서 테스트 코드를 먼저 작성하기 때문에 어떤 가정을 해야 하는지조차 알 수 없어 자연스레 목킹에서 멀어지게 됨

### private method는 어떻게 테스트해야 할까?

- 접근제어자를 default로 변경
- 리플렉션 사용
- 해당 private method를 사용하는 public method를 테스트
- 프라이빗 메서드를 테스트하려는 행위 자체가 TLD로 코드를 작성했기 때문입니다.